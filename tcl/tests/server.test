#
# server.test
#
# Test for server commands.  Some tests will be skipped if we are not on a
# known development machine, due to difficutly in certain environments.
# Set the environment variable TCLX_FULL_TESTS to override.
#------------------------------------------------------------------------------
# Copyright 1992-1995 Karl Lehenbauer and Mark Diekhans.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose and without fee is hereby granted, provided
# that the above copyright notice appear in all copies.  Karl Lehenbauer and
# Mark Diekhans make no representations about the suitability of this
# software for any purpose.  It is provided "as is" without express or
# implied warranty.
#------------------------------------------------------------------------------
# $Id: server.test,v 1.13 1995/07/03 06:35:43 markd Exp markd $
#------------------------------------------------------------------------------
#

if {[info procs test] != "test"} then {source testlib.tcl}

if ![infox have_sockets] {
    echo "NOTE: sockets were found on this system.  Is this correct?"
    return
}

#
# Do all argument and error checking.  We can at least test this, even
# if we can't run full tests on this particular system.
#

Test server-1.1 {server_connect argument checking} {
    server_connect
} 1 {wrong # args: server_connect ?options? host service|port}

Test server-1.2 {server_connect argument checking} {
    server_connect -nobuf
} 1 {wrong # args: server_connect ?options? host service|port}

Test server-1.3 {server_connect argument checking} {
    server_connect -buf
} 1 {wrong # args: server_connect ?options? host service|port}

Test server-1.4 {server_connect argument checking} {
    server_connect localhost
} 1 {wrong # args: server_connect ?options? host service|port}

Test server-1.5 {server_connect argument checking} {
    server_connect localhost echo gecko
} 1 {wrong # args: server_connect ?options? host service|port}

Test server-1.6 {server_connect argument checking} {
    server_connect -badbuf localhost echo
} 1 {expected one of "-buf", "-nobuf", "-twoids", "-myip" or "-myport", got "-badbuf"}

Test server-1.7 {server_connect argument checking} {
    server_connect -buf -badbuf localhost echo
} 1 {expected one of "-buf", "-nobuf", "-twoids", "-myip" or "-myport", got "-badbuf"}


Test server-2.0 {server_create argument checking} {
    server_create localhost
} 1 {wrong # args: server_create ?options?}

Test server-2.1 {server_create argument checking} {
    server_create localhost bad
} 1 {wrong # args: server_create ?options?}

Test server-2.2 {server_create argument checking} {
    server_create -myport 3 -buf
} 1 {expected "-myip", "-myport", "-backlog", or "-reuseaddr", got "-buf"}

Test server-2.3 {server_create argument checking} {
    server_create -myip 
} 1 {missing argument for -myip}

Test server-2.4 {server_create argument checking} {
    server_create -myip xxx
} 1 {malformed address: "xxx"}

Test server-2.5 {server_create argument checking} {
    server_create -myport 
} 1 {missing argument for -myport}

Test server-2.7 {server_create argument checking} {
    server_create -myport xxx
} 1 {expected integer but got "xxx"}


Test server-3.1 {server_accept argument checking} {
    server_accept
} 1 {wrong # args: server_accept ?options? fileid}

Test server-3.2 {server_accept argument checking} {
    server_accept -nobuf
} 1 {wrong # args: server_accept ?options? fileid}

Test server-3.3 {server_accept argument checking} {
    server_accept -buf
} 1 {wrong # args: server_accept ?options? fileid}

Test server-3.4 {server_accept argument checking} {
    server_accept bad
} 1 {bad file identifier "bad"}

Test server-3.5 {server_accept argument checking} {
    server_accept bad good ugly
} 1 {wrong # args: server_accept ?options? fileid}

Test server-3.6 {server_accept argument checking} {
    server_accept -badbuf stdin
} 1 {expected "-buf", "-nobuf" or "-twoids", got "-badbuf"}

Test server-3.7 {server_accept argument checking} {
    server_accept -buf -badbuf stdin
} 1 {expected "-buf", "-nobuf" or "-twoids", got "-badbuf"}

Test server-4.0 {server_info argument checking} {
    server_info
} 1 {wrong # args: server_info option ...}

Test server-4.1 {server_info argument checking} {
    server_info addresses
} 1 {wrong # args: server_info addresses host}

Test server-4.2 {server_info argument checking} {
    server_info addresses xxx yyy
} 1 {wrong # args: server_info addresses host}

Test server-4.3 {server_info argument checking} {
    server_info bad localhost
} 1 {invalid option "bad", expected one of "addresses", "official_name" or "aliases"}

Test server-5.1 {server_send argument checking} {
    server_send
} 1 {wrong # args: server_send [options] fileid message}

Test server-5.2 {server_send argument checking} {
    server_send x y z
} 1 {wrong # args: server_send [options] fileid message}

Test server-5.3 {server_send argument checking} {
    server_send x y
} 1 {bad file identifier "x"}

Test server-5.4 {server_send argument checking} {
    server_send -bad x y
} 1 {expected one of "-nonewline", "-outofband", or "-dontroute" got "-bad"}

Test server-5.5 {server_send argument checking} {
    server_send -nonewline -bad x y
} 1 {expected one of "-nonewline", "-outofband", or "-dontroute" got "-bad"}

Test server-6.1 {server_cntl argument checking} {
    server_cntl
} 1 {wrong # args: server_cntl fileid attribute [value]}

Test server-6.2 {server_cntl argument checking} {
    server_cntl stdin KEEPALIVE 1 1
} 1 {wrong # args: server_cntl fileid attribute [value]}

Test server-6.3 {server_cntl argument checking} {
    server_cntl stdin XKEEPALIVE 1
} 1 {unknown attribute name "XKEEPALIVE", expected KEEPALIVE}

Test server-6.4 {server_cntl argument checking} {
    server_cntl stdin KEEPALIVE XXX
} 1 {expected boolean value but got "XXX"}

#
# Determine if we are at a development site we know is good.  If we are, we
# do more checking
#
switch -glob -- [id host] {
    {*.neosoft.com} {set safeHost 1}
    {*.grizzly.com} {set safeHost 1}
    default         {set safeHost 0}
}
if [info exists env(TCLX_FULL_TESTS)] {
    set safeHost 1
}

#
# Test simple interaction with the echo server.  This proc is used to
# do the actual interaction.  The server is connected to using various
# different options and the same interaction done.
#

proc TalkToEcho {testId readFH writeFH buffered} {
    # Try gets/puts first.

    Test $testId.1 {simple client interaction} {
        puts $writeFH "Test #1"
        if $buffered {
            flush $writeFH
        }
        list [gets $readFH result] $result
    } 0 {7 {Test #1}}

    # Queue serveral messages on buffered access

    if $buffered {
        Test $testId.2 {simple client interaction} {
            puts $writeFH "Test #2"
            puts $writeFH "Test #3"
            puts $writeFH "Test #4"
            puts $writeFH "Test #5"
            puts $writeFH "Test #6"
            puts $writeFH "Test #7"
            flush $writeFH
            list [gets $readFH] [gets $readFH] [gets $readFH] \
                    [gets $readFH] [gets $readFH] [gets $readFH]
        } 0 [list {Test #2} {Test #3} {Test #4} \
                {Test #5} {Test #6} {Test #7}]
    }

    Test $testId.3 {simple client interaction} {
        server_send $writeFH "Test #8"
        list [gets $readFH result] $result
    } 0 {7 {Test #8}}

    Test $testId.4 {simple client interaction} {
        server_send $writeFH "Test #9"
        read $readFH 8
    } 0 "Test #9\n"

    Test $testId.5 {simple client interaction} {
        server_send -nonewline $writeFH "Test #10"
        read $readFH 8
    } 0 {Test #10}

    # Make sure we can dup a socket.

    Test $testId.6 {dup of a server connection} {
        set write2FH [dup $writeFH]
        if {"$readFH" != "$writeFH"} {
            set read2FH [dup $readFH]
        } else {
            set read2FH $write2FH
        }
        server_send $write2FH "Test #11"
        set stat [gets $read2FH result]

        close $write2FH
        if ![cequal $readFH $writeFH] {
            close $read2FH
        }
        list $stat $result
    } 0 {8 {Test #11}}

    # Try dup to stdin/stdout.  Skip under Tk, as fork with out exec will
    # not work.

    if [lempty [info commands button]] {
        flush stdout
        flush stderr
        if {[set pid [fork]] == 0} {
            catch {
                Test $testId.8 {dup of a server connection} {
                    dup $readFH stdin
                    dup $writeFH stdout
                    close $writeFH
                    if ![cequal $readFH $writeFH] {
                        close $readFH
                    }
                    puts stdout "Test #12"
                    flush stdout
                    list [gets stdin result] $result
                } 0 {8 {Test #12}}
            }
            exit 0
        }
        wait $pid
    }

    # Test some of the fcntl options against a socket.

    Test $testId.9 {fcntl on a server connection} {
        fcntl $readFH NOBUF
    } 0 [expr !$buffered]

    Test $testId.10 {fcntl on a server connection} {
        fcntl $writeFH NOBUF
    } 0 [expr !$buffered]

    if $buffered {
        Test $testId.11 {fcntl on a server connection} {
            # This will hang and get alarm if buffered
            alarm 120
            fcntl $writeFH NOBUF 1
            puts $writeFH "Test #13"
            set stat [gets $readFH result]
            alarm 0
            list $stat $result
        } 0 {8 {Test #13}}
    }

    Test $testId.12 {fcntl on a server connection} {
        fcntl $writeFH READ
    } 0 1

    Test $testId.13 {fcntl on a server connection} {
        fcntl $writeFH WRITE
    } 0 1
        
    # Test server_cntl on the socket.

    Test $testId.20 {server_cntl on a server connection} {
        server_cntl $writeFH KEEPALIVE 1
        server_cntl $writeFH KEEPALIVE
    } 0 1
        
    Test $testId.21 {server_cntl on a server connection} {
        server_cntl $writeFH KEEPALIVE 0
        server_cntl $writeFH KEEPALIVE
    } 0 0

    close $readFH
    if ![cequal $readFH $writeFH] {
        close $writeFH
    }
    return
}

# We might have trouble converting a hostname to IP address.  If we can't,
# just use the hostname to access.

if $safeHost {
    set maybeIP [lindex [server_info addresses [id host]] 0]
} else {
    set maybeIP [id host]
    catch {
        set maybeIP [lindex [server_info addresses [id host]] 0]
    }
}

# If we can't connect to the echo server, then skip these tests.

if [catch {
    set fh [server_connect [id host] echo]
    close $fh
} msg] {
    puts "*************************************************************"
    puts "Unable to connect to the \"echo\" server ($msg)."
    puts "Some tests skipped."
    puts "*************************************************************"
} else {

    Test server-8.1 {simple client interaction} {
        set fh [server_connect [id host] echo]
        TalkToEcho server-8.1 $fh $fh 1
    } 0 {}

    Test server-8.2 {simple client interaction} {
        set ip [lindex [server_info addresses [id host]] 0]
        set fh [server_connect -nobuf $maybeIP echo]
        TalkToEcho server-8.2 $fh $fh 0
    } 0 {}

    Test server-8.3 {simple client interaction} {
        set fh [server_connect -buf $maybeIP echo]
        TalkToEcho server-8.3 $fh $fh 1
    } 0 {}

    Test server-8.4 {simple client interaction} {
        set fhs [server_connect -twoids -buf $maybeIP echo]
        TalkToEcho server-8.4 [lindex $fhs 0] [lindex $fhs 1] 1
    } 0 {}

    Test server-8.5 {simple client interaction} {
        set fhs [server_connect -twoids -nobuf $maybeIP echo]
        TalkToEcho server-8.5 [lindex $fhs 0] [lindex $fhs 1] 0
    } 0 {}
}

#
# Fork a server to echo slightly modified versions of the messages.
#

proc TestServer {toClient} {
    set reqFH [server_create]
    puts $toClient [lindex [fstat $reqFH localhost] 2]
    flush $toClient
    set readIds $reqFH

    while 1 {
        set ready [lindex [select $readIds] 0]
        foreach id $ready {
            if [cequal $id $reqFH] {
                lappend readIds [server_accept -nobuf $reqFH]
                continue
            }
            if {[gets $id data] < 0} {
                set idx [lsearch -exact $readIds $id]
                set readIds [lreplace $readIds $idx $idx]
                continue
            }
            if [cequal $data EXIT] {
                exit
            }
            puts $id "Got \"$data\""
        }
    }
}

pipe fromServer toClient
flush stdout
flush stderr

if {[set serverPID [fork]] == 0} {
    catch {
        close $fromServer
        TestServer $toClient
        exit 0
    }
    global errorInfo
    puts stderr "Error in test server: $errorInfo"
    exit 1
}
close $toClient
if {[gets $fromServer serverPort] < 0} {
    error "Unexpected EOF from test server"
}
close $fromServer

Test server-9.1 {Tcl server} {
    set fh [server_connect -nobuf localhost $serverPort]
    puts $fh "Hello"
    set data [gets $fh]
    close $fh
    set data
} 0 {Got "Hello"}

Test server-9.2 {Tcl server} {
    set fh [server_connect -nobuf localhost $serverPort]
    puts $fh "Are you still there?"
    set data [list [gets $fh]]
    puts $fh "Are you really still there?"
    lappend data [gets $fh]
    close $fh
    set data
} 0 {{Got "Are you still there?"} {Got "Are you really still there?"}}

Test server-9.3 {Tcl server} {
    set fh [server_connect -nobuf localhost $serverPort]
    puts $fh "EXIT"
    lrange [wait $serverPID] 1 2
} 0 {EXIT 0}
